#!/bin/bash

# ========== FORENSICS TOOLKIT ==========
forensics_toolkit() {
    while true; do
        clear
        show_fox
        echo -e "${CYAN}üîç FORENSICS TOOLKIT${NC}"
        echo "===================="
        
        echo -e "${RED}‚ö†Ô∏è‚ö†Ô∏è OUTILS D'INVESTIGATION SYST√àME ‚ö†Ô∏è‚ö†Ô∏è${NC}"
        echo -e "${YELLOW}Usage l√©gal et √©thique uniquement !${NC}"
        echo ""
        
        echo -e "${GREEN}[1]${NC} üóÉÔ∏è Binwalk - Firmware Analysis (S√õRE)"
        echo -e "${GREEN}[2]${NC} üîì Foremost - File Recovery (RISQU√âE)"  
        echo -e "${GREEN}[3]${NC} üß† Volatility - Memory Analysis (S√õRE)"
        echo -e "${GREEN}[4]${NC} üíæ TestDisk - Data Recovery (TR√àS RISQU√âE)"
        echo -e "${GREEN}[5]${NC} üìä Strings - Text Extraction (S√õRE)"
        echo -e "${GREEN}[6]${NC} üîç File Analysis Suite (S√õRE)"
        echo -e "${GREEN}[7]${NC} üìã Safe Mode - Analyse seulement (RECOMMAND√âE)"
        echo -e "${GREEN}[0]${NC} ‚¨ÖÔ∏è Retour"
        
        read -r -p "Choix: " forensic_choice
        
        case $forensic_choice in
            1) run_binwalk_analysis ;;
            2) run_foremost_recovery ;;
            3) run_volatility_analysis ;;
            4) run_testdisk_recovery ;;
            5) run_strings_extraction ;;
            6) run_file_analysis_suite ;;
            7) run_safe_mode_analysis ;;
            0) return ;;
            *) 
                echo -e "${RED}‚ùå Option invalide${NC}"
                sleep 1 
                ;;
        esac
    done
}

# ========== BINWALK - FIRMWARE ANALYSIS ==========
run_binwalk_analysis() {
    # --- CO-PILOTE DE S√âLECTION DE FICHIER ---
    select_file_target "ANALYSE DE FIRMWARE (BINWALK)"
    if [[ -z "$selected_file" ]]; then return; fi
    local file="$selected_file"

    clear
    show_fox
    echo -e "${BLUE}${BOLD}üóÉÔ∏è BINWALK - ANALYSE DE: $(basename "$file")${NC}"
    echo "=================================================="
    
    if [[ ! -r "$file" ]]; then
        echo -e "${RED}‚ùå Permissions insuffisantes pour lire le fichier${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    local file_size
    file_size=$(stat -c%s "$file" 2>/dev/null)
    if [[ $file_size -gt 1073741824 ]]; then  # 1GB
        echo -e "${YELLOW}‚ö†Ô∏è Fichier volumineux (>1GB) - Cela peut prendre du temps${NC}"
        read -r -p "Continuer? (y/N): " large_confirm
        [[ "$large_confirm" != "y" ]] && return
    fi
    
    if ! command -v binwalk &>/dev/null; then
        echo -e "${RED}‚ùå Binwalk non install√©${NC}"
        read -r -p "Installer binwalk? (y/N): " install
        if [[ "$install" == "y" ]]; then
            sudo apt update && sudo apt install binwalk -y
        fi
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    mkdir -p "$PIHACK_OUTPUT_PATH/forensics"
    local output_dir
    output_dir="$PIHACK_OUTPUT_PATH/forensics/binwalk_$(basename "$file")_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$output_dir"

    echo -e "${YELLOW}‚ö° Analyse en cours...${NC}"
    echo -e "${CYAN}üìä R√©sultats de l'analyse:${NC}"
    binwalk -B "$file" | tee "$output_dir/analysis.txt" | head -50
    
    echo ""
    read -r -p "Extraire les fichiers dans un dossier s√©curis√©? (y/n): " extract
    if [[ "$extract" == "y" ]]; then
        local extract_target_dir="$output_dir/extracted_files"
        mkdir -p "$extract_target_dir"
        echo -e "${YELLOW}üìÇ Extraction dans: $extract_target_dir${NC}"
        
        binwalk -e -C "$extract_target_dir" --dd=".*" --max-size=50M "$file"
        echo -e "${GREEN}‚úÖ Extraction termin√©e dans: $extract_target_dir${NC}"
        echo -e "${CYAN}üí° Rappel: V√©rifiez le contenu avant utilisation${NC}"
    fi
    read -r -p "Appuyez sur Entr√©e..."
}

# ========== FOREMOST - FILE RECOVERY ==========
run_foremost_recovery() {
    clear
    show_fox
    echo -e "${RED}${BOLD}üîì FOREMOST - FILE RECOVERY (OP√âRATION RISQU√âE)${NC}"
    echo "=================================================="
    echo -e "${YELLOW}‚ö†Ô∏è Cet outil acc√®de directement aux disques${NC}"
    echo -e "${RED}‚ö†Ô∏è USAGE SUR VOS PROPRES DONN√âES UNIQUEMENT${NC}"
    echo ""
    
    read -r -p "Confirmez que c'est votre mat√©riel (y/N): " own_confirm
    if [[ ! "$own_confirm" =~ ^[Yy]$ ]]; then
        echo -e "${GREEN}‚úÖ Op√©ration annul√©e${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    echo -e "${YELLOW}‚ö†Ô∏è ATTENTION: Cette op√©ration peut √™tre longue et intensive${NC}"
    read -r -p "Tapez 'COMPRIS' en majuscules pour continuer: " understand
    if [[ ! "$understand" == "COMPRIS" ]]; then
        echo -e "${GREEN}‚úÖ Op√©ration annul√©e${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    echo -e "${CYAN}üíΩ P√©riph√©riques disponibles:${NC}"
    lsblk -f | grep -E "(NAME|‚îî|‚îú)"
    echo ""
    echo -e "${RED}‚ö†Ô∏è UTILISEZ SEULEMENT /dev/sdX ou des fichiers image${NC}"
    
    read -r -p "üíΩ Device/Image √† analyser (ou 'annuler'): " device
    if [[ "$device" == "annuler" || -z "$device" ]]; then
        echo -e "${GREEN}‚úÖ Op√©ration annul√©e${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    if [[ "$device" =~ ^/dev/(sda|nvme0n1)$ ]]; then
        echo -e "${RED}‚ùå DANGER: P√©riph√©rique syst√®me principal d√©tect√©${NC}"
        echo -e "${RED}‚ùå Op√©ration bloqu√©e pour votre s√©curit√©${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    mkdir -p "$PIHACK_OUTPUT_PATH/forensics"
    local output_dir
    output_dir="$PIHACK_OUTPUT_PATH/forensics/foremost_recovery_$(date +%Y%m%d_%H%M%S)"
    echo -e "${YELLOW}üìÇ Dossier de sortie: $output_dir${NC}"
    
    read -r -p "Confirmer le dossier de sortie? (y/N): " output_confirm
    if [[ ! "$output_confirm" =~ ^[Yy]$ ]]; then
        echo -e "${GREEN}‚úÖ Op√©ration annul√©e${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi

    sudo mkdir -p "$output_dir"
    sudo chown "$USER":"$USER" "$output_dir"
    
    if ! command -v foremost &>/dev/null; then
        echo -e "${RED}‚ùå Foremost non install√©${NC}"
        read -r -p "Installer foremost? (y/N): " install_foremost
        if [[ "$install_foremost" =~ ^[Yy]$ ]]; then
            sudo apt update && sudo apt install foremost -y
        fi
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    echo -e "${YELLOW}‚ö° R√©cup√©ration en cours (peut prendre du temps)...${NC}"
    echo -e "${CYAN}üí° Appuyez sur Ctrl+C pour arr√™ter si n√©cessaire${NC}"
    
    trap '' SIGINT
    timeout 1800s sudo foremost -i "$device" -o "$output_dir" -v 2>/dev/null
    local exit_code=$?
    trap cleanup_exit SIGINT SIGTERM

    if [[ $exit_code -eq 124 ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è Timeout atteint (30 min) - Processus arr√™t√©${NC}"
    elif [[ $exit_code -ne 0 ]]; then
        echo -e "${RED}‚ùå Erreur lors de la r√©cup√©ration avec Foremost (code: $exit_code)${NC}"
    else
        echo -e "${GREEN}‚úÖ R√©cup√©ration termin√©e dans: $output_dir${NC}"
        echo -e "${CYAN}üìä R√©sum√© des fichiers r√©cup√©r√©s:${NC}"
        find "$output_dir" -type f | head -10
    fi
    read -r -p "Appuyez sur Entr√©e..."
}

# ========== VOLATILITY - MEMORY ANALYSIS ==========
run_volatility_analysis() {
    # --- CO-PILOTE DE S√âLECTION DE FICHIER ---
    select_file_target "ANALYSE DE DUMP M√âMOIRE (VOLATILITY)" "*.(mem|vmem|raw|dmp)"
    if [[ -z "$selected_file" ]]; then return; fi
    local memdump="$selected_file"

    clear
    show_fox
    echo -e "${BLUE}${BOLD}üß† VOLATILITY - ANALYSE DE: $(basename "$memdump")${NC}"
    echo "=================================================="
    
    if ! command -v volatility &>/dev/null; then
        echo -e "${RED}‚ùå Volatility non install√©${NC}"
        read -r -p "Installer Volatility? (y/N): " install_vol
        if [[ "$install_vol" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}üì¶ Installation de Volatility...${NC}"
            sudo apt update && sudo apt install volatility -y
        fi
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    local dump_size
    dump_size=$(stat -c%s "$memdump" 2>/dev/null)
    echo -e "${CYAN}üìä Taille du dump: $(numfmt --to=iec "$dump_size")${NC}"
    
    if [[ $dump_size -gt 8589934592 ]]; then  # 8GB
        echo -e "${YELLOW}‚ö†Ô∏è Dump tr√®s volumineux - Analyse peut √™tre lente${NC}"
        read -r -p "Continuer? (y/N): " large_dump
        [[ "$large_dump" != "y" ]] && return
    fi
    
    echo -e "${YELLOW}‚ö° Analyse des infos syst√®me...${NC}"
    timeout 300s volatility -f "$memdump" imageinfo 2>/dev/null | head -20
    
    if [[ $? -eq 124 ]]; then
        echo -e "${RED}‚ö†Ô∏è Timeout - Dump peut √™tre corrompu ou trop gros${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}üìã Pour une analyse plus approfondie, utilisez des commandes comme:${NC}"
    echo "‚Ä¢ volatility -f \"$memdump\" --profile=Win7SP1x64 pslist"
    echo "‚Ä¢ volatility -f \"$memdump\" --profile=Win7SP1x64 netscan"

    read -r -p "Appuyez sur Entr√©e..."
}

# ========== TESTDISK - DATA RECOVERY ==========
run_testdisk_recovery() {
    clear
    show_fox
    echo -e "${RED}${BOLD}üíæ TESTDISK - DATA RECOVERY (TR√àS RISQU√âE)${NC}"
    echo "=================================================="
    echo -e "${RED}‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATTENTION - MODIFICATION POSSIBLE DES PARTITIONS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è${NC}"
    echo -e "${YELLOW}Cet outil peut MODIFIER vos partitions et donn√©es${NC}"
    echo -e "${RED}USAGE EXPERT UNIQUEMENT${NC}"
    echo ""
    
    echo -e "${YELLOW}Confirmations requises:${NC}"
    read -r -p "1. C'est votre mat√©riel? (y/N): " own_disk
    [[ "$own_disk" != "y" ]] && return
    
    read -r -p "2. Avez-vous une sauvegarde? (y/N): " have_backup
    [[ "$have_backup" != "y" ]] && return
    
    read -r -p "3. √ätes-vous expert en partitions? (y/N): " expert
    if [[ ! "$expert" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}üí° RECOMMANDATION: Utilisez l'analyse read-only${NC}"
        read -r -p "Mode analyse seulement (recommand√©)? (Y/n): " readonly_mode
        if [[ ! "$readonly_mode" =~ ^[Nn]$ ]]; then # If not 'n', assume yes for read-only
            echo -e "${CYAN}üîç Mode analyse seulement activ√©${NC}"
            echo -e "${GREEN}‚ÑπÔ∏è  TestDisk sera lanc√© en mode lecture seule${NC}"
            echo -e "${YELLOW}‚ö†Ô∏è  NE MODIFIEZ RIEN dans TestDisk${NC}"
            read -r -p "Continuer? (y/N): " final_confirm
            [[ ! "$final_confirm" =~ ^[Yy]$ ]] && return
        fi
    fi
    
    echo -e "${RED}DERNI√àRE CHANCE - Tapez 'RISQUE' en majuscules pour continuer:${NC}"
    read -r final_risk
    if [[ ! "$final_risk" == "RISQUE" ]]; then
        echo -e "${GREEN}‚úÖ Op√©ration annul√©e - Sage d√©cision${NC}"
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    if ! command -v testdisk &>/dev/null; then
        echo -e "${RED}‚ùå TestDisk non install√©${NC}"
        read -r -p "Installer TestDisk? (y/N): " install_testdisk
        if [[ "$install_testdisk" =~ ^[Yy]$ ]]; then
            sudo apt update && sudo apt install testdisk -y
        fi
        read -r -p "Appuyez sur Entr√©e..."
        return
    fi
    
    echo -e "${YELLOW}‚ö° Lancement de TestDisk...${NC}"
    echo -e "${RED}‚ö†Ô∏è RAPPEL: MODE LECTURE SEULE RECOMMAND√â${NC}"
    trap '' SIGINT
    sudo testdisk
    trap cleanup_exit SIGINT SIGTERM
    read -r -p "Appuyez sur Entr√©e..."
}

# ========== STRINGS - TEXT EXTRACTION ==========
run_strings_extraction() {
    # --- CO-PILOTE DE S√âLECTION DE FICHIER ---
    select_file_target "EXTRACTION DE STRINGS"
    if [[ -z "$selected_file" ]]; then return; fi
    local strings_file="$selected_file"

    clear
    show_fox
    echo -e "${BLUE}${BOLD}üìä STRINGS - EXTRACTION DE: $(basename "$strings_file")${NC}"
    echo "=================================================="
    
    mkdir -p "$PIHACK_OUTPUT_PATH/forensics"
    local output_file_base
    output_file_base="$PIHACK_OUTPUT_PATH/forensics/strings_$(basename "$strings_file")_$(date +%Y%m%d_%H%M%S)"

    echo -e "${YELLOW}‚ö° Extraction des strings...${NC}"
    echo -e "${CYAN}üìä Premi√®re analyse (caract√®res imprimables):${NC}"
    strings "$strings_file" | tee "${output_file_base}_preview.txt" | head -50
    
    echo ""
    read -r -p "Analyse compl√®te et sauvegarde? (y/n): " full_strings
    if [[ "$full_strings" =~ ^[Yy]$ ]]; then
        strings "$strings_file" > "${output_file_base}_full.txt"
        echo -e "${GREEN}‚úÖ Strings sauvegard√©es dans: ${output_file_base}_full.txt${NC}"
        local total_strings
        total_strings=$(wc -l < "${output_file_base}_full.txt")
        echo -e "${CYAN}üìä Total strings: $total_strings${NC}"
    fi
    read -r -p "Appuyez sur Entr√©e..."
}

# ========== FILE ANALYSIS SUITE ==========
run_file_analysis_suite() {
    # --- CO-PILOTE DE S√âLECTION DE FICHIER ---
    select_file_target "SUITE D'ANALYSE DE FICHIER"
    if [[ -z "$selected_file" ]]; then return; fi
    local analysis_file="$selected_file"

    clear
    show_fox
    echo -e "${BLUE}${BOLD}üîç FILE ANALYSIS SUITE sur: $(basename "$analysis_file")${NC}"
    echo "=================================================="
    
    mkdir -p "$PIHACK_OUTPUT_PATH/forensics"
    local output_file_base
    output_file_base="$PIHACK_OUTPUT_PATH/forensics/file_analysis_$(basename "$analysis_file")_$(date +%Y%m%d_%H%M%S)"

    echo -e "${CYAN}üîç ANALYSE COMPL√àTE:${NC}"
    echo "=================="
    
    # Informations de base
    echo -e "${YELLOW}üìã Informations de base:${NC}"
    ls -la "$analysis_file" | tee "${output_file_base}_info.txt"
    file "$analysis_file" | tee -a "${output_file_base}_info.txt"
    
    # Hash du fichier
    echo ""
    echo -e "${YELLOW}üîê Hashes:${NC}"
    echo "MD5:    $(md5sum "$analysis_file" | cut -d' ' -f1)" | tee "${output_file_base}_hashes.txt"
    echo "SHA256: $(sha256sum "$analysis_file" | cut -d' ' -f1)" | tee -a "${output_file_base}_hashes.txt"
    
    # Analyse hexad√©cimale des premiers bytes
    echo ""
    echo -e "${YELLOW}üî¢ Header hexad√©cimal:${NC}"
    hexdump -C "$analysis_file" | head -10 | tee "${output_file_base}_hex_header.txt"
    
    # Recherche de strings int√©ressantes
    echo ""
    echo -e "${YELLOW}üìù Strings int√©ressantes:${NC}"
    strings "$analysis_file" | (grep -i -E "(password|user|admin|key|token|secret)" || true) | head -10 | tee "${output_file_base}_strings.txt"
    
    echo ""
    echo -e "${GREEN}‚úÖ Analyse termin√©e. R√©sultats dans: $PIHACK_OUTPUT_PATH/forensics/${NC}"
    read -r -p "Appuyez sur Entr√©e..."
}

# ========== SAFE MODE - ANALYSE SEULEMENT ==========
run_safe_mode_analysis() {
    # --- CO-PILOTE DE S√âLECTION DE FICHIER ---
    select_file_target "ANALYSE EN MODE SANS √âCHEC"
    if [[ -z "$selected_file" ]]; then return; fi
    local safe_file="$selected_file"

    clear
    show_fox
    echo -e "${GREEN}üìã SAFE MODE - ANALYSE DE: $(basename "$safe_file")${NC}"
    echo "================================"

    mkdir -p "$PIHACK_OUTPUT_PATH/forensics"
    local output_file_base
    output_file_base="$PIHACK_OUTPUT_PATH/forensics/safe_analysis_$(basename "$safe_file")_$(date +%Y%m%d_%H%M%S)"

    echo -e "${GREEN}üîí ANALYSE S√âCURIS√âE:${NC}"
    echo "===================="
    
    # Analyse compl√®tement s√ªre
    echo -e "${CYAN}üìã Type: $(file "$safe_file" | cut -d: -f2)${NC}" | tee "${output_file_base}_info.txt"
    echo -e "${CYAN}üìä Taille: $(du -h "$safe_file" | cut -f1)${NC}" | tee -a "${output_file_base}_info.txt"
    echo -e "${CYAN}üîê MD5: $(md5sum "$safe_file" | cut -d' ' -f1)${NC}" | tee -a "${output_file_base}_info.txt"
    echo -e "${CYAN}üîê SHA256: $(sha256sum "$safe_file" | cut -d' ' -f1)${NC}" | tee -a "${output_file_base}_info.txt"
    
    echo ""
    echo -e "${YELLOW}üìù Aper√ßu strings (safe):${NC}"
    strings "$safe_file" | head -20 | tee "${output_file_base}_strings_preview.txt"
    
    echo ""
    echo -e "${GREEN}‚úÖ Analyse safe termin√©e - Aucune modification. R√©sultats dans: $PIHACK_OUTPUT_PATH/forensics/${NC}"
    read -r -p "Appuyez sur Entr√©e pour continuer..."
}
